## lab3-0实验报告

姓名:陈炳楠

学号:PB17111650

### 1.实验要求
本次实验主要分为两个部分。第一部分是手工将c语言代码翻译成LLVM IR
代码，第二部分是c++语言通过调用LLVM IR库来实现cpp翻译LLVM IR代码。
### 2.实验结果
#### 2.1 赋值
在手工翻译部分，需要注意内存的分配，值的存储，以及重新取出数值时的操作。<br>
在cpp翻译部分，将模块名命名为assign，将main函数部分的翻译作为一个basicblock。在这个函数内部主要实现了变量的赋值及返回操作。需要注意basicblock使用时的插入点的操作，以及c++语言对应的内存分配，存储，取值的操作。并且还有相应的对于插入点的清除，module的清除等不一样的细节部分。
#### 2.2 条件
在手工翻译部分，将常数作为变量来分配内存和存入数据。之后重新取出进行
条件判断进行跳转。并根据跳转部分不同返回不同的数值。<br>
在cpp翻译部分，采用了和手工翻译一样的思路，将main函数开始初始化部分作为一个basicblock，里面创建了变量存值以及取值。之后的三个basicblock分别是判断正确部分，判读错误部分
以及返回值部分。前两个部分最终都会跳转到返回值部分将存储的计算结果返回。
#### 2.3 循环
在手工翻译部分，在初识化后所有部分都会跳转到while部分，之后会在while
内条件判断决定是跳转到while内的循环部分还是跳出while循环。<br>
在cpp翻译部分首先设定一个entry模块，作为初始化的设定部分，在这里对a和i的值进行赋值
之后跳转到判断模块，这里通过比较判断确定下一次的跳转块是while内部的操作还是
退出while循环块。在while块内实现了对i的递增和累加。在返回块部分，在内存中取出a的
值返回。
#### 2.4 调用
在手工翻译部分，将两个函数分别定义，作为main和callee函数。可以对这
两个函数通过名字定义后的数字`#0`(举例)做相同的属性定义。<br>
在cpp翻译部分需要定义两个module，一个是实现callee函数，另一个是
main函数。在callee部分定义一个basicblock，在这里实现返回两倍传入的参数值。
在main函数部分，定义一个basicblock块，在其中做callee的调用以及值的
返回。
#### 2.5 综合比对
通过上述几个例子可以看出。LLVM IR的不同函数部分对应于cpp部分的module
模块，每一个划分不同的执行部分(比如不同条件跳转的执行部分)对应于LLVM IR中
不同的basicblock。我们通过插入basicblock点来实现分块和跳转。<br>
对于变量的声明、赋值、取值，分别是cpp中的`builder.CreateAlloca(TYPE32)`,
`builder.CreateStore(CONST(1), aAlloca)`,`builder.CreateLoad(aAlloca)`
(举例)。<br>
对于LLVM IR中函数值的返回则是对应cpp中的`builder.CreateRet(aLoad)`(举例)。
### 3.实验难点
#### (1)手工编写部分
在手工编写开始部分，我参考了通过指令得出的文件，通过它的帮助实现
了一些属性的基本赋值。其中attributes的开头
` noinline nounwind optnone uwtable `当时没有在意便直接
复制到自己的版本中后来发现这句话会让我的备注没法保存，每次重新运行
后我的注释都会消失并且会加上官方版的注释。之后通过查阅发现工具会
自动帮我们做一些相关的优化。
#### (2)cpp翻译部分
-1.开始时对于函数参数的设置不够敏感，导致调用时的参数不匹配问题，后来
将其更改过来。<br>
-2.对于cpp生成翻译的basicblock顺序存在理解错误。开始时以为
生成的LLVM IR代码的basicblock会和我使用的顺序相同，但结果并不是这样，它会做一些调整，这导致了代码跳转顺序错误，无法运行的问题。
### 4.实验总结
这次实验难度适中，并且助教提供了很好的实例代码可以供我们学习
借鉴，是很好的一个帮助。本次的学习知识和平时接触的汇编语言，C语言很类似，容易上手。<br>
并且实验的内容和最近上课的内容和相似，比如语法制导翻译的做出标记，记录下跳转的地方。
这一部分和cpp翻译的`builder.SetInsertPoint();`思想很类似，两边的结合帮助我更好理解地理解了编译器的翻译方面的知识。<br>
